# S/W 품질과 OOAD

## ▶️ 품질이 좋은 S/W란?

* 모든 기업들이 목표로 하는 것 = 품질!

* 품질이 좋은 S/W의 조건
  
  * 1️⃣ 분석이 분명하고, 쉬워야 함
    
    * 분명하면서 이해가 잘되어야 함
    
    * 복잡도가 낮아야 함
  
  * 2️⃣ 설계가 탄탄해야 함
    
    * 유지보수가 효과적이어야 함
    
    * 테스트가 좋아야 함
    
    * 확장이 쉬워야 함

## ▶️ 품질이 좋은 S/W를 개발하기 위해

> **구성원들이 같은 청사진을 갖고, 정형화된 개발 프로세스를 통해 빠르게 개발**

* 개발을 하기 전 분석과 설계를 철저히

* 분석과 설계에 miscommunication이 없도록 문서화

* Agile 개발 프로세스

* 코드리뷰, TDD, Clean Code 등

## ▶️ OOAD란?

> Object-Oriented Analysis and Design

* 객체기반으로 개발되는 S/W에 대한 분석과 설계 방법을 뜻함

* **분석, 설계의 산출물 = Diagram 기반 모델링 언어를 통한 문서화**

## ▶️ UML

> **객체지향설계 표기법의 표준**

* 분석 / 설계의 최종 결과물 → UML Diagram

# OOP

## ▶️ 객체지향 개발 방법

* 독립적으로 수행하는 역할을 나누어 운영하는 시스템화가 필요

* 재사용성이 좋음

## ▶️ 클래스의 등장

* 객체 단위로 구현하기 시작
  
  * 클래스로 객체를 구현

* C언어
  
  * 전역변수/함수 중심의 개발

* C++ / Java
  
  * 클래스(전역변수+함수) 중심의 개발

## ▶️ 객체지향의 장점

* 유지 보수성이 좋음
  
  * 연관된 클래스만 코드를 변경

* 재사용성 좋음
  
  * 만들어 둔 객체를 다른 곳에서도 사용 가능
  
  * 외부에서 만든 객체를 가져다 쓰기 편리

* 협업 가능
  
  * 절차지향에 비해, 담당 파트를 정하기 편리

# 클래스 다루기

## ▶️ Server Code & Client Code

* Server Code
  
  * Client 요청을 받으면 처리해주는 코드
  
  * Library == Server code

* Client Code
  
  * Server Code에게 일을 요청하는 코드
  
  * Library 사용자 == Client Code

# 캡슐화

> **허용하지 않는 데이터/필드 접근을 막음 = 데이터 제어 가능**

* Client들은 Readme 를 읽지 않는다.

* 읽지 않는 Readme 내용
  
  * 해당 클래스(계산기) 사용 시 divide에 / 0 이 되지 않도록 하시오.
  
  * result 변수를 사용하지 마시오.

* **Server Code Level 에서 이를 제한해야 함!**
  
  * private로 접근하지 못하도록 막기
  
  * Client가 어떻게 사용하더라도 버그가 발생하지 않도록 처리

## ▶️ 캡슐화 장점

* Server Code가 허용한 방법대로 Client Code를 작성하도록 유도

# 상속

> **부모가 가진 요소들을 자식들이 물려받아 사용할 수 있음**

* OOP 상속은 부모/자식 관계로 보기 어려움
  
  * **코드 중복 방지를 위해 공통적인 요소를 일반화 시킴**

## ▶️ 중복 코드의 문제점

* 중복된 메서드/필드들이 존재
  
  * 중복 코드가 문제되는 이유: 변경 시 모두 다 한꺼번에 수정 필요 / 버그 유발

## ▶️ 객체와 분류 관계

* `is a` 관계 = 객체 is a 클래스 가 성립!

## ▶️ Overloading/Overriding

* Overloading
  
  * 같은 이름의 메서드이지만, 다른 Argument로 함수 구분 = 파라미터를 다르게 사용!

* Overriding
  
  * Super class 메서드 재정의 = 부모 클래스의 메서드를 재정의 (파라미터까지 모두 똑같이!)






