# 그래프 (Graph)

> 실생활의 문제를 그래프로 추상화해서 해결

* 그래프는 아이템(사물 또는 추상적 개념)들과 이들 사이의 연결 관계를 표현

* 그래프는 정점(Vertex)들의 집합과 이들을 연결하는 간선들의 집합으로 구성
  
  * V = 정점의 개수, E = 그래프에 포함된 간선의 개수
  
  * V 개의 정점을 가지는 그래프는 최대 `V * (V-1) / 2` 간선이 가능
    
    * 5개 정점의 그래프 = 최대 간선 수 10`(5*4 / 2)`개

* 선형 자료구조나 트리 자료구조로 표현하기 어려운 N:N 관계를 가지는 원소들을 표현하기 용이하다.

## ▶ 그래프 종류

* 무향 그래프(Undirected Graph)
  
  ![](Graph_assets/2022-09-28-02-01-05-image.png)

* 유향 그래프(Directed Graph)
  
  ![](Graph_assets/2022-09-28-02-01-26-image.png)

* 가중치 그래프(Weighted Graph)
  
  ![](Graph_assets/2022-09-28-02-01-34-image.png)

* 사이클 없는 방향 그래프(DAG, Directed Acyclic Graph)

![](Graph_assets/2022-09-28-09-11-24-image.png)

* 완전 그래프 - 정점들에 대해 가능한 모든 간선들을 가진 그래프
  
  ![](Graph_assets/2022-09-28-09-11-49-image.png)

* 부분 그래프 - 원래 그래프에서 일부의 정점이나 간선을 제외한 그래프

## ▶ 인접 정점

> 두 개의 정점에 간선이 존재하면 서로 인접해 있다고 함

* 완전 그래프에 속한 임의의 두 정점들은 모두 인접해 있다.

* **경로 중 한 정점을 최대한 한 번만 지나는 경로를 단순경로라 함**

* **시작한 정점에서 끝나는 경로를 사이클이라고 함**

![](Graph_assets/2022-09-28-09-13-03-image.png)

## ▶ 그래프 표현

> 간선의 정보를 저장하는 방식, 메모리나 성능을 고려해서 결정

* 인접 행렬 (Adjacent matrix)
  
  * V * V 크기의 2차원 배열을 이용해서 간선 정보를 저장
  
  * 배열의 배열(포인터 배열)

* 인접 리스트 (Adjacent List)
  
  * 각 정점마다 해당 정점으로 나가는 간선의 정보를 저장

* 간선의 배열
  
  * 간선(시작 정점, 끝 정점)을 배열에 연속적으로 저장

## ▶ 인접 행렬

> 두 정점을 연결하는 간선의 유무를 행렬로 표현

* V * V 정방 행렬

* 행 번호와 열 번호는 그래프의 정점에 대응

* 두 정점이 인접되어 있으면 1, 그렇지 않으면 0으로 표현

* 무향 그래프
  
  * i번째 행의 합 = i번째 열의 합 = Vi 의 차수
    
    ![](Graph_assets/2022-09-28-09-21-27-image.png)
* 유향 그래프
  * 행 i의 합 = Vi 의 진출 차수
  
  * 열 i의 합 = Vi의 진입 차수

![](Graph_assets/2022-09-28-09-25-22-image.png)

### 📌 인접행렬의 단점

* 정점이 많아질수록 2차원 배열 내 빈공간이 많아질 가능성 높다.

* 탐색하기 어려움

![](Graph_assets/2022-09-28-09-26-35-image.png)

## ▶ 인접 리스트

> 각 정점에 대한 인접 정점들을 순차적으로 표현

* 하나의 정점에 대한 인접 정점들을 각각 노드로 하는 연결 리스트로 저장

![](Graph_assets/2022-09-28-09-27-39-image.png)

# DFS

> 친구 관계, 비상연락망 등을 그래프로 표현 가능

## ▶ 그래프 순회

> 비선형구조인 그래프로 표현된 모든 자료(정점)를 빠짐없이 탐색하는 것

* 두 가지 방법
  
  * DFS (깊이 우선 탐색)
  
  * BFS (너비 우선 탐색)

## ▶ DFS (깊이우선탐색)

> 시작 정점의 한 방향으로 갈 수 있는 경로가 있는 곳까지 깊이 탐색해 가다가 더 이상 갈 곳이 없게 되면, 가장 마지막에 만났던 갈림길 간선이 있는 정점으로 되돌아와서 다른 방향의 정점으로 탐색을 계속 반복하여 결국 모든 정점을 방문하는 순회방법

* 가장 마지막에 만났던 갈림길의 정점으로 되돌아가서 다시 깊이 우선탐색을 반복해야 하므로 **후입선출 구조의 스택 사용**❗

### 📌 stack의 특성

* **선형구조 - 자료 간의 관계가 1:1의 관계**
  
  * 비선형구조 - 자료 간의 관계가 1:N의 관계 (트리)

* **마지막에 삽입한 자료를 가장 먼저 꺼낸다 = LIFO(후입선출)**

### 📌 stack 구현

* 자료를 선형으로 저장할 저장소 - 배열 (마지막에 삽입된 원소의 위치를 `top`이라 부름)

* 연산 - `push`, `pop`, `isEmpty`, `peek`

* 삽입/삭제 과정

![](Graph_assets/2022-09-28-09-47-11-image.png)

* **DFS 알고리즘 - 재귀**

```python
# 재귀호출
def dfs(v):
    visited[v] = 1

    for w in adjList[v]:
        # 방문하지 않은 w
        if visited[w] == 0:
            dfs(w)
```

* **DFS 알고리즘 - 반복**

```python
stack = []
visited = []

def dfs(v):
    stack.append(v)
    visited[v] = 1
    while stack:
        v = stack.pop()
        visited[v] = 1
        for w in adjList[v]:
            if visited[w] == 0:
                stack.append(w)
                visited[w] = 1    
                break
```

# BFS (너비우선탐색)

> 탐색 시작점의 인접한 정점들을 먼저 모두 차례로 방문한 후에 방문했던 정점을 시작점으로 하여 다시 인접한 정점들을 차례로 방문하는 방식

* 인접한 정점들에 대해 탐색을 한 후, 차례로 다시 너비우선탐색을 진행하므로 선입선출 형태의 자료구조인 큐를 활용

### 📌 Queue 의 특성

* 스택과 마찬가지로 삽입과 삭제의 위치가 제한적인 자료구조
  
  * **queue의 뒤에서는 삽입만 하고, queue의 앞에서는 삭제만 이루어지는 구조**

* **queue에 삽입한 순서대로 원소가 저장되어, 가장 먼저 삽입된 원소는 가장 먼저 삭제**
  
  * **FIFO, 선입선출 구조**

![](Graph_assets/2022-09-28-17-23-15-image.png)

* BFS 알고리즘

```python
def bfs(v, n):
    q.append(v)
    visited[v] = 1

    while q:
        w = q.pop(0)
        print(w, end=' ')
        visited[v] = 1

        for i in adjList[w]:
            if not visited[i]:
                q.append(i)
                visited[i] = visited[n] + 1
```

# 서로소 집합들

> 서로소 또는 상호배타 집합들은 서로 중복 포함된 원소가 없는 집합 = 교집합 X

* 집합에 속한 하나의 특정 멤버를 통해 각 집합들을 구분한다. 이를 대표자라고 한다.

* 상호배타 집합을 표현하는 방법
  
  * 연결 리스트
  
  * 트리

* 연산
  
  * `Make-Set(x)` - x 가 대표원소 집합 만들어
  
  * `Find-Set(x)` - x 가 속한 집합의 대표원소를 반환 예) `return y`
  
  * `Union(x, y)` - x 가 대표원소인 집합과 y 가 대표원소인 집합을 합쳐

![](Graph_assets/2022-09-28-17-48-40-image.png)

* 트리
  
  * 하나의 집합을 하나의 트리로 표현
  
  * 자식 노드가 부모 노드를 가리키며 로트 노드가 대표자가 된다.

![](Graph_assets/2022-09-28-17-50-26-image.png)

* 연산 예

![](Graph_assets/2022-09-28-17-55-45-image.png)

* `Union(d, f)` 
  
  * d의 대표 원소를 찾고 f의 대표원소를 찾자
  
  * f의 대표 원소를 d의 대표원소로 교체

![](Graph_assets/2022-09-28-17-58-47-image.png)

* 상호 배타 집합을 표현한 트리의 배열을 이용한 저장된 모습

![](Graph_assets/2022-09-28-18-00-38-image.png)

* 상호배타 집합에 대한 연산
  
  * `Make-Set(x)` - 유일한 멤버 x를 포함하는 새로운 집합을 생성
  
  * `Find-Set(x)` - x를 포함하는 집합을 찾음
  
  * `Union(x,y)` - x와 y를 포함하는 두 집합을 통합
