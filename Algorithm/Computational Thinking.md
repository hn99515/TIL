- [ ] # 프로그래밍과 논리/수학

## ▶ 논리 (Hard Logic)

* **카드 문제**
  
  * 주장: 만약 한 쪽이 D 이면 반대쪽은 3
  
  * 사실인지 확인하기 위해  반드시 뒤집어 보아야 하는 것은 몇 개이고 어느 것인가?
    
    ![](Computational%20Thinking_assets/2022-09-14-01-33-32-image.png)

* 답: `D` 와 `7`
  
  * **3 뒤에 D가 있든 없든 주장이 사실인지 여부에 영향이 없음**
  
  * **7 뒤에 D가 있으면 주장이 성립하지 않게 됨**

### 📌 [참고]

* **명제**
  
  * **참이나 거짓을 알 수 있는 식이나 문장**
  
  * `p`, `q`, `r` ... 로 표현

* **진릿값**
  
  * **참이나 거짓을 표현**
  
  * `T`, `F` or `1`, `0`

* **부정 NOT**
  
  * p가 명제일 때, 명제의 진릿값이 반대
  
  * `~p` 로 표기
    
    ![](Computational%20Thinking_assets/2022-09-14-01-41-20-image.png)

* **논리곱 AND**
  
  * p, q가 명제일 때, **p, q 모두 참일 때만 참이 되는 명제**
  
  * `p ^ q`
    
    ![](Computational%20Thinking_assets/2022-09-14-01-42-51-image.png)

* **논리합 OR**
  
  * p, q 가 명제일 때, **p, q 모두 거짓일 때만 거짓이 되는 명제**
  
  * `p V q`
    
    ![](Computational%20Thinking_assets/2022-09-14-01-43-43-image.png)

* **배타적 논리합 XOR**
  
  * p, q가 명제일 때, **p, q 중 하나만 참일 때 참이 되는 명제**
  
  * `p ⊕ q`
    
    ![](Computational%20Thinking_assets/2022-09-14-01-44-50-image.png)

* **조건 명제**
  
  * p, q 가 명제일 때, **명제 p가 조건, q가 결론으로 제시되는 명제**
  
  * `p –> q`
    
    * **p가 F 면 `p –> q` True**
    
    * **q가 T 면 `p –> q` True**
      
      **![](Computational%20Thinking_assets/2022-09-14-01-50-36-image.png)**

* **쌍방조건명제**
  
  * p, q가 명제일 때, **명제 p와 q가 모두 조건이면서 결론인 명제**
  
  * **`p <–> q`**
    
    **![](Computational%20Thinking_assets/2022-09-14-02-03-05-image.png)**

* **조건 명제의 역, 이, 대우**
  
  * 역: `q –> p` (T T F T)
  
  * 이: `~p –> ~q` (T T F T)
  
  * 대우: `~q –> ~p` (T F T T)
    
    ![](Computational%20Thinking_assets/2022-09-14-09-46-08-image.png)
  
  * <mark>**p가 False 면 q가 무엇이든 True**</mark>❗
  
  * <mark>**q가 True 면 p가 무엇이든 True**</mark>❗

# 증명

> 정확한 명제식으로 표현할 수 있는 것

* 증명에 대한 수많은 오해가 `p –> q` 를 `p <–> q`와 혼동
* **수학적 귀납법**
  * 수학적 귀납법 기본형
    * `P(1)`이 참이고, `P(n) -> P(n+1)`이 참이면 `P(n)`은 모든 자연수 n에 대하여 참❗
  * 수학적 귀납법 강한형태
    * `P(1)`이 참이고, `P(1) ^ P(2) ^ ... ^ P(n) -> P(n+1)` 이 참이면 `P(n)`은 모든 자연수 n에 대하여 참❗

# 수와 표현

* **컴퓨터는 `0` 과 `1`을 표현할 수 있는 비트들을 모아 수를 표현**

* **k개의 비트를 사용하면 `0 ~ 2^k-1` 까지 표현 가능 (`2^k` 가지)**

* **어떤 값 n을 표현하기 위해서는 몇 개의 비트가 필요할까❓**
  
  * `2**k - 1 >= n` 이 성립해야 함 : `2**k >= n + 1`
  
  * 로그를 사용하면 약 `log n` 비트가 필요 (`x = log n` 과 `2**x = n` 같은 말)
    
    ### 📌 log n 의 의미
    
    * **2의 몇 승이 n 이 되는가?**
    
    * **n을 표현하는데 몇 비트가 필요한가?**
    
    * **1로 시작해서 계속 두 배를 할 때 몇 번하면 n이 되는가?**
    
    * **n을 2로 계속 나눌 때 몇 번 나누면 1이 되는가?**

# 집합과 조합론

> 두 집합 A 와 B 에 대해 A 가 B의 부분집합임을 증명 = A의 임의의 원소가 B에 포함됨을 보이는 것

* ex.
  
  * 모든 4의 배수는 2의 배수다 : 4k = 2(2k) 임을 보이면 된다.
  
  * 두 집합 A와 B가 같다는 것을 증명 = A가 B의 부분집합 & B가 A의 부분집합임을 증명 

# 기초 수식

> 알고리즘의 시간 복잡도를 계산 할 수 있고, 알고리즘의 시간이 얼마나 걸릴지 예측 가능

# 재귀

> 자기 자신을 호출하는 함수
