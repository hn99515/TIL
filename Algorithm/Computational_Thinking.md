# 프로그래밍과 논리/수학

## ▶ 논리 (Hard Logic)

* **카드 문제**
  
  * 주장: 만약 한 쪽이 D 이면 반대쪽은 3
  
  * 사실인지 확인하기 위해  반드시 뒤집어 보아야 하는 것은 몇 개이고 어느 것인가?
    
    ![](Computational%20Thinking_assets/2022-09-14-01-33-32-image.png)

* 답: `D` 와 `7`
  
  * **3 뒤에 D가 있든 없든 주장이 사실인지 여부에 영향이 없음**
  
  * **7 뒤에 D가 있으면 주장이 성립하지 않게 됨**

### 📌 [참고]

* **명제**
  
  * **참이나 거짓을 알 수 있는 식이나 문장**
  
  * `p`, `q`, `r` ... 로 표현

* **진릿값**
  
  * **참이나 거짓을 표현**
  
  * `T`, `F` or `1`, `0`

* **부정 NOT**
  
  * p가 명제일 때, 명제의 진릿값이 반대
  
  * `~p` 로 표기
    
    ![](Computational%20Thinking_assets/2022-09-14-01-41-20-image.png)

* **논리곱 AND**
  
  * p, q가 명제일 때, **p, q 모두 참일 때만 참이 되는 명제**
  
  * `p ^ q`
    
    ![](Computational%20Thinking_assets/2022-09-14-01-42-51-image.png)

* **논리합 OR**
  
  * p, q 가 명제일 때, **p, q 모두 거짓일 때만 거짓이 되는 명제**
  
  * `p V q`
    
    ![](Computational%20Thinking_assets/2022-09-14-01-43-43-image.png)

* **배타적 논리합 XOR**
  
  * p, q가 명제일 때, **p, q 중 하나만 참일 때 참이 되는 명제**
  
  * `p ⊕ q`
    
    ![](Computational%20Thinking_assets/2022-09-14-01-44-50-image.png)

* **조건 명제**
  
  * p, q 가 명제일 때, **명제 p가 조건, q가 결론으로 제시되는 명제**
  
  * `p –> q`
    
    * **p가 F 면 `p –> q` True**
    
    * **q가 T 면 `p –> q` True**
      
      **![](Computational%20Thinking_assets/2022-09-14-01-50-36-image.png)**

* **쌍방조건명제**
  
  * p, q가 명제일 때, **명제 p와 q가 모두 조건이면서 결론인 명제**
  
  * **`p <–> q`**
    
    **![](Computational%20Thinking_assets/2022-09-14-02-03-05-image.png)**

* **조건 명제의 역, 이, 대우**
  
  * 역: `q –> p` (T T F T)
  
  * 이: `~p –> ~q` (T T F T)
  
  * 대우: `~q –> ~p` (T F T T)
    
    ![](Computational%20Thinking_assets/2022-09-14-09-46-08-image.png)
  
  * <mark>**p가 False 면 q가 무엇이든 True**</mark>❗
  
  * <mark>**q가 True 면 p가 무엇이든 True**</mark>❗

# 증명

> 정확한 명제식으로 표현할 수 있는 것

* 증명에 대한 수많은 오해가 `p –> q` 를 `p <–> q`와 혼동
* **수학적 귀납법**
  * 수학적 귀납법 기본형
    * `P(1)`이 참이고, `P(n) -> P(n+1)`이 참이면 `P(n)`은 모든 자연수 n에 대하여 참❗
  * 수학적 귀납법 강한형태
    * `P(1)`이 참이고, `P(1) ^ P(2) ^ ... ^ P(n) -> P(n+1)` 이 참이면 `P(n)`은 모든 자연수 n에 대하여 참❗

# 수와 표현

* **컴퓨터는 `0` 과 `1`을 표현할 수 있는 비트들을 모아 수를 표현**

* **k개의 비트를 사용하면 `0 ~ 2^k-1` 까지 표현 가능 (`2^k` 가지)**

* **어떤 값 n을 표현하기 위해서는 몇 개의 비트가 필요할까❓**
  
  * `2**k - 1 >= n` 이 성립해야 함 : `2**k >= n + 1`
  
  * 로그를 사용하면 약 `log n` 비트가 필요 (`x = log n` 과 `2**x = n` 같은 말)
    
    ### 📌 log n 의 의미
    
    * **2의 몇 승이 n 이 되는가?**
    
    * **n을 표현하는데 몇 비트가 필요한가?**
    
    * **1로 시작해서 계속 두 배를 할 때 몇 번하면 n이 되는가?**
    
    * **n을 2로 계속 나눌 때 몇 번 나누면 1이 되는가?**

### 📌 예시

* 2진수 표현에서 log n 비트로 표현할 수 있는 숫자 범위는? `n`

# 집합과 조합론

> 두 집합 A 와 B 에 대해 A 가 B의 부분집합임을 증명 = A의 임의의 원소가 B에 포함됨을 보이는 것

* ex.
  
  * 모든 4의 배수는 2의 배수다 : 4k = 2(2k) 임을 보이면 된다.
  
  * 두 집합 A와 B가 같다는 것을 증명 = A가 B의 부분집합 & B가 A의 부분집합임을 증명 

### 📌 예시

* 비밀번호를 0 ~ 9 까지의 숫자로 구성. 4개 이상 6개 이하의 숫자로 설정할 수 있다면 가능한 비밀번호의 가지 수는? 4개 = `10**4` + 5개 = `10**5` + 6개 = `10**6`

* 52개의 카드를 이용하여 5개 카드 선정 시 같은 무늬의 카드가 정확히 3개인 경우는?
  
  * ``4C1 * 13C3 * 3C2 * 13C1 * 13C1`
    
    * 카드 종류 4개 중 1개는 13개 숫자 중 3개 선택
    
    * 나머지 카드 종류 3개 중 2개는 13개 숫자 중 1개씩 선택

* 52개 카드에서 5개 카드 조합을 만들 때, 숫자가 같은 카드가 한 쌍도 없는 경우는 몇 가지?
  
  * 방법 1 = `13C5 * 4 * 4 * 4 * 4 * 4`
    
    * 숫자가 같은 카드는 13개 중의 5개
    
    * 각 자리에 들어올 수 있는 카드 종류는 4장
  
  * 방법 2 = `52C1 * 48C1 * 44C1 * 40C1 * 36C1 / 5!`
    
    * 전체 카드 중 같은 숫자 3장 제거 후 남은 카드에서 다시 1개 선택
    
    * 순서에 의한 경우의 수로 나눠야 정확한 답이 나옴

# 기초 수식

> 알고리즘의 시간 복잡도를 계산 할 수 있고, 알고리즘의 시간이 얼마나 걸릴지 예측 가능

### 📌 예시

* T(n) = T(n-1) + 1, T(0) = 1
  
  * T(n-2) + 1 + 1
  
  * T(n-3) +1 +1 +1 
  
  * `T(n-k) + k`
    
    * n = k 라면, T(0) + n = `1 + n`
    
    * 시간복잡도 = `O(n)`

* T(n) = T(n-1) + n, T(0) = 1
  
  * T(n-2) + n + n-1
  
  * `T(n-k) + kn - k`
    
    * n = k 라면, T(0) + k(k-1) = `n**2 - n`
    
    * 시간복잡도 = `O(n**2)`

* T(n) = T(n-1) + log n, T(0) = 1
  
  * T(n-2) + log n + log (n-1)
  
  * `T(n-k) + log (n-k+1) + ... + log (n-1) + log n`
    
    * n = k 라면, T(0) + log 1 + ... + log (n-1) + log n
    
    * `1 + log n! <= 1 + log n**n = 1 + n*log n`
    
    * `n! <= n**n` 이므로 `log n! <= log n**n` 이다.
    
    * 시간복잡도 = `O(n log n)`

* T(n) = T(n/2) + 1, T(1) = 1
  
  * T(n/4) + 1 + 1
  
  * T(n/2**k) + k
    
    * `(n/2**k ) = 1`이므로  `n = 2**k `이다. 즉, `k = log n`
    
    * l + log n
    
    * 시간복잡도 = `O(log n)`

# 재귀

> 자기 자신을 호출하는 함수

* 함수는 입력이 있으며, 자기 자신의 입력과 동일한 입력으로 자신을 호출하면 당연히 끝나지 않는다❗
  
  * 단, 자기 자신이 아닌 다른 입력으로 호출하면 끝날 수 있다❗

```python
def sum(int(x)):
    if int(x) <= 0:
        return 0
    else:
        return x + sum(x-1)
```

![](Computational%20Thinking_assets/2022-09-15-01-14-38-image.png)

### 📌 예시

* 피보나치 수열을 재귀 알고리즘으로 작성하고, 시간복잡도를 계산
  
  * F(n) = F(n-1) + F(n-2), F(1) = F(2) = 1

```python
def fibo(n):
    if n <= 2:
        return 1
    else:
        return f(n-1) + f(n-2)
```

* 시간복잡도 = `O(2**n)`
  
  * `T(n) = T(n-1) + T(n-2) +1` 
  
  * **위 식은 T(n-1) + T(n-1) + 1 보다 작다. = `2T(n-1) + 1`**
  
  * 따라서, `T(n) < 2T(n-1) + 1` 이다.
    
    * 2(2T(n-2) + 1) +1
    
    * `2**k * T(n-k) + 2**(k-1) + ... + 2 + 1`
      
      * n = k 라면, `2**n + (1- 2**n/1-2) = 2**n `

# 동적 프로그래밍

> **재귀 함수에서 동일한 입력의 함수 호출이 반복적으로 일어날 때 그 결과 값을 저장해 두고 불러 쓰는 것**이다. = **Memoization**

* 최초 입력에서 파생되는 모든 가능한 입력에 대한 답을 모두 저장할 수 있는 메모리가 있어야 한다.

* 단순히 재귀에서 저장된 값을 찾아보는 것으로도 가능하지만, 결과값을 순서를 정해서 계산할 수도 있다 (**Dynamic Programming**)

### 📌 예시

* 피보나치 수열을 DP 로 표현하기

```python
dp = [0] * (n+1)
dp[0] = 0
dp[1] = 1

for i in range(n+1):
    dp[n] = dp[n-1] + dp[n-2]
```

* 시간복잡도 = `O(n)`
